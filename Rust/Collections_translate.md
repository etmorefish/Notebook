# 集合类型

> std::collections

 Rust 的标准集合库提供了最常见通用编程数据结构的高效实现。通过使用 标准实现，应该可以让两个库在不需要重大数据转换的情况下进行通信。

 首先说明：你很可能只需要使用 [`Vec`] 或 [`HashMap`]。 这两个集合覆盖了大多数通用数据存储和处理的用例。

 它们在执行它们的任务时非常出色。标准库中的所有其他集合都有特定的用例， 在这些情况下它们是最优选择，但与 `Vec` 和 `HashMap` 相比，这些情况几乎是*小众* 的。即使在 `Vec` 和 `HashMap` 技术上不是最优选择时，它们
 也可能是一个很好的足够好的选择来开始。

 Rust 的集合可以分为四个主要类别：

 * 序列：[`Vec`]、[`VecDeque`]、[`LinkedList`]
 * 映射：[`HashMap`]、[`BTreeMap`]
 * 集合：[`HashSet`]、[`BTreeSet`]
 * 杂项：[`BinaryHeap`]

 # 你应该在什么时候使用哪种集合？

 这些都是关于每种集合应该被考虑的相当高层次和快速的分解。
 关于个别集合的优势和劣势的详细讨论可以在它们自己的文档页面上找到。

 ### 使用 `Vec` 时：
 * 你想要收集项目以便稍后处理或发送到其他地方，并且不在乎实际存储的值的任何属性。
 * 你想要一个特定顺序的元素序列，并且只会在（或接近）末尾添加。
 * 你想要一个栈。
 * 你想要一个可调整大小的数组。
 * 你想要一个堆分配的数组。

 ### 使用 `VecDeque` 时：
 * 你想要一个支持在序列两端高效插入的 [`Vec`]。
 * 你想要一个队列。
 * 你想要一个双端队列（deque）。

 ### 使用 `LinkedList` 时：
 * 你想要一个未知大小的 [`Vec`] 或 [`VecDeque`]，并且不能容忍摊销。
 * 你想要高效地分割和追加列表。
 * 你 *绝对* 确定你 *真的*、*真正* 想要一个双向链表。

 ### 使用 `HashMap` 时：
 * 你想要将任意键与任意值相关联。
 * 你想要一个缓存。
 * 你想要一个没有额外功能的映射。

 ### 使用 `BTreeMap` 时：
 * 你想要的映射的键是排序的。
 * 你想要按需获取一系列条目。
 * 你有兴趣知道最小或最大的键值对是什么。
 * 你想要找到比某个东西小或大的最大或最小键。

 ### 使用这些 `Map`s 的 `Set` 变体时：
 * 你只是想要记住你已经看到哪些键。
 * 你的键没有有意义的值与之关联。
 * 你只是想要一个集合。

 ### 使用 `BinaryHeap` 时：

 * 你想要存储一堆元素，但只想在任何给定时间处理 "最大" 或 "最重要" 的一个。
 * 你想要一个优先队列。

 # 性能

 选择正确的集合来完成工作需要了解每个集合擅长什么。
 这里我们简要总结不同集合对某些重要操作的性能。有关更多详细信息， 请参见每种类型的文档，并注意，由于某些集合的不同，实际方法的名称可能 与下面的表格不同。

 在整个文档中，我们将遵循一些约定。对于所有操作，集合的大小 用 n 表示。如果另一个集合参与操作，它包含 m 个元素。具有 *摊销* 成本的操作都带有 `*` 后缀。具有 *预期* 成本的操作 带有 `~` 后缀。

 所有摊销成本都是因为潜在的需要在容量耗尽时调整大小。 如果发生调整大小，它将需要 *O*(*n*) 时间。我们的集合从不自动缩小， 所以删除操作不是摊销的。在足够大的一系列操作中，每个操作的平均成本 将确定性地等于给定成本。

 只有 [`HashMap`] 有预期成本，这是由于哈希的随机性质。 理论上，尽管非常不可能，[`HashMap`] 可能会经历更差的性能。

 ## 序列

|                | get(i)                 | insert(i)               | remove(i)              | append    | split_off(i)           |
|----------------|------------------------|-------------------------|------------------------|-----------|------------------------|
| [`Vec`]        | *O*(1)                 | *O*(*n*-*i*)*           | *O*(*n*-*i*)           | *O*(*m*)* | *O*(*n*-*i*)           |
| [`VecDeque`]   | *O*(1)                 | *O*(min(*i*, *n*-*i*))* | *O*(min(*i*, *n*-*i*)) | *O*(*m*)* | *O*(min(*i*, *n*-*i*)) |
| [`LinkedList`] | *O*(min(*i*, *n*-*i*)) | *O*(min(*i*, *n*-*i*))  | *O*(min(*i*, *n*-*i*)) | *O*(1)    | *O*(min(*i*, *n*-*i*)) |

 请注意，在出现平局的情况下，[`Vec`] 通常比 [`VecDeque`] 更快， 而 [`VecDeque`] 通常比 [`LinkedList`] 更快。

 # 正确和高效地使用集合

 当然，知道哪种集合适合工作并不能立即让你正确地使用它。 这里是一些快速提示，用于一般地高效和正确使用标准集合。如果你 对于如何特别使用特定集合感兴趣，请查阅其文档以获取详细讨论和代码示例。

 ## 容量管理

 许多集合提供了几个引用 "容量" 的构造函数和方法。这些集合通常建立在 一个数组之上。
 理想情况下，这个数组的大小正好只适合存储集合中的元素， 但如果集合一直这样做将非常低效。如果后备数组始终是正确的大小， 那么每次插入一个元素时，集合都必须增长数组以适应它。由于大多数计算机上 内存的分配和管理方式，这几乎肯定需要分配一个全新的数组， 并将旧数组中的每个元素复制到新数组中。 希望你可以看到，每次操作都这样做将非常低效。

 因此，大多数集合使用了一个 *摊销* 的分配策略。它们通常让自己有相当多的 未占用空间，以便它们只在偶尔需要增长。当它们增长时，它们会分配 一个更大的数组来移动元素，以便在需要再次增长之前需要一段时间。 虽然这种策略总体上很好，但如果集合 *永远* 不必调整其后备数组， 那将会更好。不幸的是，集合本身没有足够的信息来自行完成这项工作。 因此，这取决于我们程序员给它提示。

 任何 `with_capacity` 构造函数都会指示集合分配足够的空间来容纳指定数量的元素。 理想情况下，这将是确切的那么多元素，但某些实现细节可能会阻止这样做。 有关详细信息，请参见集合特定的文档。一般来说，当你确切知道将插入多少元素时， 或者至少对那个数字有一个合理的上限时，使用 `with_capacity`。

 当预期将有大量元素涌入时，可以使用 `reserve` 系列方法来提示集合 为即将到来的项目腾出多少空间。与 `with_capacity` 一样，这些方法的确切行为 将特定于感兴趣的集合。

 为了获得最佳性能，集合通常会避免缩小自己。如果你认为集合 不久将不再包含任何元素，或者真的需要内存，`shrink_to_fit` 方法会提示 集合将后备数组缩小到能够容纳其元素的